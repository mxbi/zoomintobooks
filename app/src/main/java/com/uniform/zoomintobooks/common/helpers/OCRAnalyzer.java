package com.uniform.zoomintobooks.common.helpers;

import android.content.Context;
import android.media.Image;

import com.google.android.gms.tasks.OnFailureListener;
import com.google.android.gms.tasks.OnSuccessListener;
import com.google.android.gms.tasks.Task;
import com.google.ar.core.Frame;
import com.google.ar.core.exceptions.NotYetAvailableException;
import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import com.google.gson.stream.JsonReader;
import com.google.mlkit.vision.common.InputImage;
import com.google.mlkit.vision.text.Text;
import com.google.mlkit.vision.text.TextRecognition;
import com.google.mlkit.vision.text.TextRecognizer;

import android.net.Uri;
import android.os.Build;
import android.util.Log;
import android.widget.Toast;

import org.json.JSONObject;

import java.io.File;
import java.io.FileDescriptor;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.lang.reflect.Type;
import java.net.URI;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Scanner;

import androidx.annotation.NonNull;
import androidx.annotation.RequiresApi;
import me.xdrop.fuzzywuzzy.FuzzySearch;
import me.xdrop.fuzzywuzzy.model.ExtractedResult;

import static me.xdrop.fuzzywuzzy.FuzzySearch.ratio;

public class OCRAnalyzer {
    private TextRecognizer recognizer = TextRecognition.getClient();
    // Only do one image at a time
    private boolean blocked = false;
    private LinkedHashMap<Integer, String> textDatabase;
    private Context context;
    private Toast lastToast;
    private final String MATCHING_MODE = "full";

    public boolean isBlocked() {
        return blocked;
    }

    public OCRAnalyzer(FileDescriptor textDatabase, Context context) {

        String text = "{\"41\": \"PETERSON-AND-DAVIE 07-ch01-000-069-9780123850591 2011/11/1 9:29 Page 9 #10\\n\\n1.2 Requirements\\n\\n9\\n\\n(a)\\n\\n(b)\\n\\nI FIGURE 1.2 Direct links: (a) point-to-point; (b) multiple-access.\\n\\nfollowing two examples of how a collection of computers can be indirectly\\nconnected.\\n\\nFigure 1.3 shows a set of nodes, each of which is attached to one or\\nmore point-to-point links. Those nodes that are attached to at least two\\nlinks run software that forwards data received on one link out on another.\\nIf organized in a systematic way, these forwarding nodes form a switched\\nnetwork. There are numerous types of switched networks, of which the\\ntwo most common are circuit switched and packet switched. The former\\nis most notably employed by the telephone system, while the latter is\\nused for the overwhelming majority of computer networks and will be\\nthe focus of this book. (Circuit switching is, however, making a bit of a\\ncomeback in the optical networking realm, which turns out to be impor-\\ntant as demand for network capacity constantly grows.) The important\\nfeature of packet-switched networks is that the nodes in such a network\\nsend discrete blocks of data to each other. Think of these blocks of data as\\ncorresponding to some piece of application data such as a le, a piece of\\nemail, or an image. We call each block of data either a packet or a message,\\nand for now we use these terms interchangeably; we discuss the reason\\nthey are not always the same in Section 1.2.3.\\n\\nPacket-switched networks typically use a strategy called store-and-\\nforward. As the name suggests, each node in a store-and-forward network\\nrst receives a complete packet over some link, stores the packet in its\\ninternal memory, and then forwards the complete packet to the next\\n\\n\\f\", \"42\": \"PETERSON-AND-DAVIE 07-ch01-000-069-9780123850591 2011/11/1 9:29 Page 10 #11\\n\\n10\\n\\nCHAPTER 1 Foundation\\n\\nI FIGURE 1.3 Switched network.\\n\\nnode. In contrast, a circuit-switched network rst establishes a dedicated\\ncircuit across a sequence of links and then allows the source node to send\\na stream of bits across this circuit to a destination node. The major rea-\\nson for using packet switching rather than circuit switching in a computer\\nnetwork is efciency, discussed in the next subsection.\\n\\nThe cloud in Figure 1.3 distinguishes between the nodes on the inside\\nthat implement the network (they are commonly called switches, and\\ntheir primary function is to store and forward packets) and the nodes\\non the outside of the cloud that use the network (they are commonly\\ncalled hosts, and they support users and run application programs). Also\\nnote that the cloud in Figure 1.3 is one of the most important icons of\\ncomputer networking. In general, we use a cloud to denote any type of\\nnetwork, whether it is a single point-to-point link, a multiple-access link,\\nor a switched network. Thus, whenever you see a cloud used in a gure,\\n\\n\\f\", \"43\": \"PETERSON-AND-DAVIE 07-ch01-000-069-9780123850591 2011/11/1 9:29 Page 11 #12\\n\\n1.2 Requirements\\n\\n11\\n\\nI FIGURE 1.4 Interconnection of networks.\\n\\nyou can think of it as a placeholder for any of the networking technologies\\ncovered in this book.2\\n\\nA second way in which a set of computers can be indirectly connected\\nis shown in Figure 1.4. In this situation, a set of independent networks\\n(clouds) are interconnected to form an internetwork, or internet for short.\\nWe adopt the Internets convention of referring to a generic internet-\\nwork of networks as a lowercase i internet, and the currently operational\\nTCP/IP Internet as the capital I Internet. A node that is connected to two\\nor more networks is commonly called a router or gateway, and it plays\\nmuch the same role as a switchit forwards messages from one net-\\nwork to another. Note that an internet can itself be viewed as another\\nkind of network, which means that an internet can be built from an\\ninterconnection of internets. Thus, we can recursively build arbitrarily\\nlarge networks by interconnecting clouds to form larger clouds. It can\\n\\n2Interestingly, the use of clouds in this way predates the term cloud computing by at\\nleast a couple of decades, but there is a connection between these two usages, which\\nwell discuss later.\\n\\n\\f\", \"44\": \"PETERSON-AND-DAVIE 07-ch01-000-069-9780123850591 2011/11/1 9:29 Page 12 #13\\n\\n12\\n\\nCHAPTER 1 Foundation\\n\\nreasonably be argued that this idea of interconnecting widely differing\\nnetworks was the fundamental innovation of the Internet and that the\\nsuccessful growth of the Internet to global size and billions of nodes\\nwas the result of some very good design decisions by the early Internet\\narchitects, which we will discuss later.\\n\\nJust because a set of hosts are directly or indirectly connected to each\\nother does not mean that we have succeeded in providing host-to-host\\nconnectivity. The nal requirement is that each node must be able to\\nsay which of the other nodes on the network it wants to communicate\\nwith. This is done by assigning an address to each node. An address is a\\nbyte string that identies a node; that is, the network can use a nodes\\naddress to distinguish it from the other nodes connected to the network.\\nWhen a source node wants the network to deliver a message to a certain\\ndestination node, it species the address of the destination node. If the\\nsending and receiving nodes are not directly connected, then the switches\\nand routers of the network use this address to decide how to forward the\\nmessage toward the destination. The process of determining systemati-\\ncally how to forward messages toward the destination node based on its\\naddress is called routing.\\n\\nThis brief introduction to addressing and routing has presumed that\\nthe source node wants to send a message to a single destination node\\n(unicast). While this is the most common scenario, it is also possible that\\nthe source node might want to broadcast a message to all the nodes on the\\nnetwork. Or, a source node might want to send a message to some subset\\nof the other nodes but not all of them, a situation called multicast. Thus,\\nin addition to node-specic addresses, another requirement of a network\\nis that it support multicast and broadcast addresses.\\n\\nThe main idea to take away from this discussion is that we can define a network\\nrecursively as consisting of two or more nodes connected by a physical link, or\\nas two or more networks connected by a node. In other words, a network can be\\nconstructed from a nesting of networks, where at the bottom level, the network is\\nimplemented by some physical medium. Among the key challenges in providing\\nnetwork connectivity are the definition of an address for each node that is reach-\\nable on the network (including support for broadcast and multicast), and the\\nuse of such addresses to forward messages toward the appropriate destination\\nnode(s).\\n\\n\\f\", \"45\": \"PETERSON-AND-DAVIE 07-ch01-000-069-9780123850591 2011/11/1 9:29 Page 13 #14\\n\\n1.2 Requirements\\n\\n13\\n\\n1.2.3 Cost-Effective Resource Sharing\\n\\nAs stated above, this book focuses on packet-switched networks. This\\nsection explains the key requirement of computer networksefciency\\nthat leads us to packet switching as the strategy of choice.\\n\\nGiven a collection of nodes indirectly connected by a nesting of net-\\nworks, it is possible for any pair of hosts to send messages to each other\\nacross a sequence of links and nodes. Of course, we want to do more than\\nsupport just one pair of communicating hostswe want to provide all\\npairs of hosts with the ability to exchange messages. The question, then,\\nis how do all the hosts that want to communicate share the network, espe-\\ncially if they want to use it at the same time? And, as if that problem isnt\\nhard enough, how do several hosts share the same link when they all want\\nto use it at the same time?\\n\\nTo understand how hosts share a network, we need to introduce a fun-\\ndamental concept, multiplexing, which means that a system resource is\\nshared among multiple users. At an intuitive level, multiplexing can be\\nexplained by analogy to a timesharing computer system, where a single\\nphysical processor is shared (multiplexed) among multiple jobs, each of\\nwhich believes it has its own private processor. Similarly, data being sent\\nby multiple users can be multiplexed over the physical links that make up\\na network.\\n\\nTo see how this might work, consider the simple network illustrated in\\nFigure 1.5, where the three hosts on the left side of the network (senders\\nS1S3) are sending data to the three hosts on the right (receivers R1R3)\\nby sharing a switched network that contains only one physical link. (For\\nsimplicity, assume that host S1 is sending data to host R1, and so on.)\\nIn this situation, three ows of datacorresponding to the three pairs of\\nhostsare multiplexed onto a single physical link by switch 1 and then\\ndemultiplexed back into separate ows by switch 2. Note that we are being\\nintentionally vague about exactly what a ow of data corresponds to.\\nFor the purposes of this discussion, assume that each host on the left\\nhas a large supply of data that it wants to send to its counterpart on the\\nright.\\n\\nThere are several different methods for multiplexing multiple ows\\nonto one physical link. One common method is synchronous time-\\ndivision multiplexing (STDM). The idea of STDM is to divide time into\\nequal-sized quanta and, in a round-robin fashion, give each ow a chance\\n\\n\\f\", \"46\": \"PETERSON-AND-DAVIE 07-ch01-000-069-9780123850591 2011/11/1 9:29 Page 14 #15\\n\\n14\\n\\nCHAPTER 1 Foundation\\n\\nS1\\n\\nS2\\n\\nS3\\n\\nSwitch 1\\n\\nSwitch 2\\n\\nR1\\n\\nR2\\n\\nR3\\n\\nI FIGURE 1.5 Multiplexing multiple logical flows over a single physical link.\\n\\nto send its data over the physical link. In other words, during time quan-\\ntum 1, data from S1 to R1 is transmitted; during time quantum 2, data\\nfrom S2 to R2 is transmitted; in quantum 3, S3 sends data to R3. At\\nthis point, the rst ow (S1 to R1) gets to go again, and the process\\nrepeats. Another method is frequency-division multiplexing (FDM). The\\nidea of FDM is to transmit each ow over the physical link at a different\\nfrequency, much the same way that the signals for different TV stations\\nare transmitted at a different frequency over the airwaves or on a coaxial\\ncable TV link.\\n\\nAlthough simple to understand, both STDM and FDM are limited in\\ntwo ways. First, if one of the ows (host pairs) does not have any data\\nto send, its share of the physical linkthat is, its time quantum or its\\nfrequencyremains idle, even if one of the other ows has data to trans-\\nmit. For example, S3 had to wait its turn behind S1 and S2 in the previous\\nparagraph, even if S1 and S2 had nothing to send. For computer com-\\nmunication, the amount of time that a link is idle can be very largefor\\nexample, consider the amount of time you spend reading a web page\\n(leaving the link idle) compared to the time you spend fetching the page.\\nSecond, both STDM and FDM are limited to situations in which the maxi-\\nmum number of ows is xed and known ahead of time. It is not practical\\n\\n\\f\", \"47\": \"PETERSON-AND-DAVIE 07-ch01-000-069-9780123850591 2011/11/1 9:29 Page 15 #16\\n\\n1.2 Requirements\\n\\n15\\n\\nto resize the quantum or to add additional quanta in the case of STDM or\\nto add new frequencies in the case of FDM.\\n\\nThe form of multiplexing that addresses these shortcomings, and of\\nwhich we make most use in this book, is called statistical multiplexing.\\nAlthough the name is not all that helpful for understanding the concept,\\nstatistical multiplexing is really quite simple, with two key ideas. First, it\\nis like STDM in that the physical link is shared over timerst data from\\none ow is transmitted over the physical link, then data from another ow\\nis transmitted, and so on. Unlike STDM, however, data is transmitted from\\neach ow on demand rather than during a predetermined time slot. Thus,\\nif only one ow has data to send, it gets to transmit that data without wait-\\ning for its quantum to come around and thus without having to watch the\\nquanta assigned to the other ows go by unused. It is this avoidance of\\nidle time that gives packet switching its efciency.\\n\\nAs dened so far, however, statistical multiplexing has no mechanism\\nto ensure that all the ows eventually get their turn to transmit over the\\nphysical link. That is, once a ow begins sending data, we need some\\nway to limit the transmission, so that the other ows can have a turn.\\nTo account for this need, statistical multiplexing denes an upper bound\\non the size of the block of data that each ow is permitted to transmit at\\na given time. This limited-size block of data is typically referred to as a\\npacket, to distinguish it from the arbitrarily large message that an applica-\\ntion program might want to transmit. Because a packet-switched network\\nlimits the maximum size of packets, a host may not be able to send a\\ncomplete message in one packet. The source may need to fragment the\\nmessage into several packets, with the receiver reassembling the packets\\nback into the original message.\\n\\nIn other words, each ow sends a sequence of packets over the physical\\nlink, with a decision made on a packet-by-packet basis as to which ows\\npacket to send next. Notice that, if only one ow has data to send, then it\\ncan send a sequence of packets back-to-back; however, should more than\\none of the ows have data to send, then their packets are interleaved on\\nthe link. Figure 1.6 depicts a switch multiplexing packets from multiple\\nsources onto a single shared link.\\n\\nThe decision as to which packet to send next on a shared link can be\\nmade in a number of different ways. For example, in a network consisting\\nof switches interconnected by links such as the one in Figure 1.5, the\\n\\n\\f\", \"48\": \"PETERSON-AND-DAVIE 07-ch01-000-069-9780123850591 2011/11/1 9:29 Page 16 #17\\n\\n16\\n\\nCHAPTER 1 Foundation\\n\\nI FIGURE 1.6 A switch multiplexing packets from multiple sources onto one shared link.\\n\\ndecision would be made by the switch that transmits packets onto the\\nshared link. (As we will see later, not all packet-switched networks actu-\\nally involve switches, and they may use other mechanisms to determine\\nwhose packet goes onto the link next.) Each switch in a packet-switched\\nnetwork makes this decision independently, on a packet-by-packet basis.\\nOne of the issues that faces a network designer is how to make this deci-\\nsion in a fair manner. For example, a switch could be designed to service\\npackets on a rst-in, rst-out (FIFO) basis. Another approach would be\\nto transmit the packets from each of the different ows that are currently\\nsending data through the switch in a round-robin manner. This might be\\ndone to ensure that certain ows receive a particular share of the links\\nbandwidth or that they never have their packets delayed in the switch\\nfor more than a certain length of time. A network that attempts to allo-\\ncate bandwidth to particular ows is sometimes said to support quality of\\nservice (QoS), a topic that we return to in Chapter 6.\\n\\nAlso, notice in Figure 1.6 that since the switch has to multiplex three\\nincoming packet streams onto one outgoing link, it is possible that the\\nswitch will receive packets faster than the shared link can accommodate.\\nIn this case, the switch is forced to buffer these packets in its mem-\\nory. Should a switch receive packets faster than it can send them for\\nan extended period of time, then the switch will eventually run out of\\n\\n\\f\", \"49\": \"PETERSON-AND-DAVIE 07-ch01-000-069-9780123850591 2011/11/1 9:29 Page 17 #18\\n\\n1.2 Requirements\\n\\n17\\n\\nbuffer space, and some packets will have to be dropped. When a switch\\nis operating in this state, it is said to be congested.\\n\\nThe bottom line is that statistical multiplexing defines a cost-effective way for\\nmultiple users (e.g., host-to-host flows of data) to share network resources (links\\nand nodes) in a fine-grained manner. It defines the packet as the granularity with\\nwhich the links of the network are allocated to different flows, with each switch\\nable to schedule the use of the physical links it is connected to on a per-packet\\nbasis. Fairly allocating link capacity to different flows and dealing with congestion\\nwhen it occurs are the key challenges of statistical multiplexing.\\n\\nSANs, LANs, MANs, and WANs\\n\\nOne way to characterize networks is according to their size. Two well-known\\nexamples are local area networks (LANs) and wide area networks (WANs);\\nthe former typically extend less than 1 km, while the latter can be worldwide.\\nOther networks are classified as metropolitan area networks (MANs), which\\nusually span tens of kilometers. The reason such classifications are interest-\\ning is that the size of a network often has implications for the underlying\\ntechnology that can be used, with a key factor being the amount of time it\\ntakes for data to propagate from one end of the network to the other; we\\ndiscuss this issue more in later chapters.\\n\\nAn interesting historical note is that the term wide area network was not\\napplied to the first WANs because there was no other sort of network to dif-\\nferentiate them from. When computers were incredibly rare and expensive,\\nthere was no point in thinking about how to connect all the computers in\\nthe local areathere was only one computer in that area. Only as comput-\\ners began to proliferate did LANs become necessary, and the term WAN\\nwas then introduced to describe the larger networks that interconnected\\ngeographically distant computers.\\n\\nAnother kind of network that we need to be aware of is SANs (usually\\nnow expanded as storage area networks, but formerly also known as sys-\\ntem area networks). SANs are usually confined to a single room and connect\\nthe various components of a large computing system. For example, Fibre\\nChannel is a common SAN technology used to connect high-performance\\ncomputing systems to storage servers and data vaults. Although this book\\ndoes not describe such networks in detail, they are worth knowing about\\nbecause they are often at the leading edge in terms of performance, and\\nbecause it is increasingly common to connect such networks into LANs\\nand WANs.\\n\\n\\f\", \"50\": \"PETERSON-AND-DAVIE 07-ch01-000-069-9780123850591 2011/11/1 9:29 Page 18 #19\\n\\n18\\n\\nCHAPTER 1 Foundation\\n\\n1.2.4 Support for Common Services\\n\\nThe previous section outlined the challenges involved in providing cost-\\neffective connectivity among a group of hosts, but it is overly simplistic to\\nview a computer network as simply delivering packets among a collection\\nof computers. It is more accurate to think of a network as providing the\\nmeans for a set of application processes that are distributed over those\\ncomputers to communicate. In other words, the next requirement of a\\ncomputer network is that the application programs running on the hosts\\nconnected to the network must be able to communicate in a meaningful\\nway. From the application developers perspective, the network needs to\\nmake his or her life easier.\\n\\nWhen two application programs need to communicate with each\\nother, a lot of complicated things must happen beyond simply sending\\na message from one host to another. One option would be for application\\ndesigners to build all that complicated functionality into each application\\nprogram. However, since many applications need common services, it is\\nmuch more logical to implement those common services once and then\\nto let the application designer build the application using those services.\\nThe challenge for a network designer is to identify the right set of com-\\nmon services. The goal is to hide the complexity of the network from the\\napplication without overly constraining the application designer.\\n\\nIntuitively, we view the network as providing logical channels over\\nwhich application-level processes can communicate with each other;\\neach channel provides the set of services required by that application. In\\nother words, just as we use a cloud to abstractly represent connectivity\\namong a set of computers, we now think of a channel as connecting one\\nprocess to another. Figure 1.7 shows a pair of application-level processes\\ncommunicating over a logical channel that is, in turn, implemented on\\ntop of a cloud that connects a set of hosts. We can think of the channel as\\nbeing like a pipe connecting two applications, so that a sending applica-\\ntion can put data in one end and expect that data to be delivered by the\\nnetwork to the application at the other end of the pipe.\\n\\nThe challenge is to recognize what functionality the channels should\\nprovide to application programs. For example, does the application\\nrequire a guarantee that messages sent over the channel are delivered,\\nor is it acceptable if some messages fail to arrive? Is it necessary that mes-\\nsages arrive at the recipient process in the same order in which they are\\nsent, or does the recipient not care about the order in which messages\\n\\n\\f\", \"51\": \"PETERSON-AND-DAVIE 07-ch01-000-069-9780123850591 2011/11/1 9:29 Page 19 #20\\n\\n1.2 Requirements\\n\\n19\\n\\nHost\\n\\nHost\\n\\nApplication\\n\\nHost\\n\\nApplication\\n\\nHost\\n\\nHost\\n\\nI FIGURE 1.7 Processes communicating over an abstract channel.\\n\\narrive? Does the network need to ensure that no third parties are able\\nto eavesdrop on the channel, or is privacy not a concern? In general, a\\nnetwork provides a variety of different types of channels, with each appli-\\ncation selecting the type that best meets its needs. The rest of this section\\nillustrates the thinking involved in dening useful channels.\\n\\nIdentifying Common Communication Patterns\\nDesigning abstract channels involves rst understanding the communi-\\ncation needs of a representative collection of applications, then extracting\\ntheir common communication requirements, and nally incorporating\\nthe functionality that meets these requirements in the network.\\n\\nOne of the earliest applications supported on any network is a le\\naccess program like the File Transfer Protocol (FTP) or Network File Sys-\\ntem (NFS). Although many details varyfor example, whether whole les\\nare transferred across the network or only single blocks of the le are read/\\nwritten at a given timethe communication component of remote le\\naccess is characterized by a pair of processes, one that requests that a\\nle be read or written and a second process that honors this request. The\\n\\n\\f\", \"52\": \"PETERSON-AND-DAVIE 07-ch01-000-069-9780123850591 2011/11/1 9:29 Page 20 #21\\n\\n20\\n\\nCHAPTER 1 Foundation\\n\\nprocess that requests access to the le is called the client, and the process\\nthat supports access to the le is called the server.\\n\\nReading a le involves the client sending a small request message to a\\nserver and the server responding with a large message that contains the\\ndata in the le. Writing works in the opposite waythe client sends a large\\nmessage containing the data to be written to the server, and the server\\nresponds with a small message conrming that the write to disk has taken\\nplace.\\n\\nA digital library is a more sophisticated application than le transfer,\\nbut it requires similar communication services. For example, the Associ-\\nation for Computing Machinery (ACM) operates a large digital library of\\ncomputer science literature at\\n\\nhttp://portal.acm.org/dl.cfm\\n\\nThis library has a wide range of searching and browsing features to help\\nusers nd the articles they want, but ultimately much of what it does\\nis respond to user requests for les, such as electronic copies of journal\\narticles, much like an FTP server.\\n\\nUsing le access, a digital library, and the two video applications\\ndescribed in the introduction (videoconferencing and video on demand)\\nas a representative sample, we might decide to provide the following two\\ntypes of channels: request/reply channels and message stream channels.\\nThe request/reply channel would be used by the le transfer and digital\\nlibrary applications. It would guarantee that every message sent by one\\nside is received by the other side and that only one copy of each message\\nis delivered. The request/reply channel might also protect the privacy and\\nintegrity of the data that ows over it, so that unauthorized parties cannot\\nread or modify the data being exchanged between the client and server\\nprocesses.\\n\\nThe message stream channel could be used by both the video on\\ndemand and videoconferencing applications, provided it is parameter-\\nized to support both one-way and two-way trafc and to support different\\ndelay properties. The message stream channel might not need to guaran-\\ntee that all messages are delivered, since a video application can operate\\nadequately even if some video frames are not received. It would, however,\\nneed to ensure that those messages that are delivered arrive in the same\\norder in which they were sent, to avoid displaying frames out of sequence.\\nLike the request/reply channel, the message stream channel might want\\n\\n\\f\", \"53\": \"PETERSON-AND-DAVIE 07-ch01-000-069-9780123850591 2011/11/1 9:29 Page 21 #22\\n\\n1.2 Requirements\\n\\n21\\n\\nto ensure the privacy and integrity of the video data. Finally, the message\\nstream channel might need to support multicast, so that multiple parties\\ncan participate in the teleconference or view the video.\\n\\nWhile it is common for a network designer to strive for the smallest\\nnumber of abstract channel types that can serve the largest number of\\napplications, there is a danger in trying to get away with too few channel\\nabstractions. Simply stated, if you have a hammer, then everything looks\\nlike a nail. For example, if all you have are message stream and request/\\nreply channels, then it is tempting to use them for the next application that\\ncomes along, even if neither type provides exactly the semantics needed by\\nthe application. Thus, network designers will probably be inventing new\\ntypes of channelsand adding options to existing channelsfor as long\\nas application programmers are inventing new applications.\\n\\nAlso note that independent of exactly what functionality a given chan-\\nnel provides, there is the question of where that functionality is imple-\\nmented. In many cases, it is easiest to view the host-to-host connectivity\\nof the underlying network as simply providing a bit pipe, with any high-\\nlevel communication semantics provided at the end hosts. The advantage\\nof this approach is that it keeps the switches in the middle of the network\\nas simple as possiblethey simply forward packetsbut it requires the\\nend hosts to take on much of the burden of supporting semantically rich\\nprocess-to-process channels. The alternative is to push additional func-\\ntionality onto the switches, thereby allowing the end hosts to be dumb\\ndevices (e.g., telephone handsets). We will see this question of how vari-\\nous network services are partitioned between the packet switches and the\\nend hosts (devices) as a recurring issue in network design.\\n\\nReliability\\nAs suggested by the examples just considered, reliable message delivery\\nis one of the most important functions that a network can provide. It\\nis difcult to determine how to provide this reliability, however, without\\nrst understanding how networks can fail. The rst thing to recognize is\\nthat computer networks do not exist in a perfect world. Machines crash\\nand later are rebooted, bers are cut, electrical interference corrupts bits\\nin the data being transmitted, switches run out of buffer space, and, as\\nif these sorts of physical problems arent enough to worry about, the\\nsoftware that manages the hardware may contain bugs and sometimes\\nforwards packets into oblivion. Thus, a major requirement of a network\\n\\n\\f\", \"54\": \"PETERSON-AND-DAVIE 07-ch01-000-069-9780123850591 2011/11/1 9:29 Page 22 #23\\n\\n22\\n\\nCHAPTER 1 Foundation\\n\\nis to recover from certain kinds of failures, so that application programs\\ndont have to deal with them or even be aware of them.\\n\\nThere are three general classes of failure that network designers have\\nto worry about. First, as a packet is transmitted over a physical link, bit\\nerrors may be introduced into the data; that is, a 1 is turned into a 0 or\\nvice versa. Sometimes single bits are corrupted, but more often than not a\\nburst error occursseveral consecutive bits are corrupted. Bit errors typi-\\ncally occur because outside forces, such as lightning strikes, power surges,\\nand microwave ovens, interfere with the transmission of data. The good\\nnews is that such bit errors are fairly rare, affecting on average only one\\nout of every 106 to 107 bits on a typical copper-based cable and one out\\nof every 1012 to 1014 bits on a typical optical ber. As we will see, there\\nare techniques that detect these bit errors with high probability. Once\\ndetected, it is sometimes possible to correct for such errorsif we know\\nwhich bit or bits are corrupted, we can simply ip themwhile in other\\ncases the damage is so bad that it is necessary to discard the entire packet.\\nIn such a case, the sender may be expected to retransmit the packet.\\n\\nThe second class of failure is at the packet, rather than the bit, level;\\nthat is, a complete packet is lost by the network. One reason this can hap-\\npen is that the packet contains an uncorrectable bit error and therefore\\nhas to be discarded. A more likely reason, however, is that one of the nodes\\nthat has to handle the packetfor example, a switch that is forwarding it\\nfrom one link to anotheris so overloaded that it has no place to store\\nthe packet and therefore is forced to drop it. This is the problem of con-\\ngestion mentioned in Section 1.2.3. Less commonly, the software running\\non one of the nodes that handles the packet makes a mistake. For exam-\\nple, it might incorrectly forward a packet out on the wrong link, so that\\nthe packet never nds its way to the ultimate destination. As we will see,\\none of the main difculties in dealing with lost packets is distinguishing\\nbetween a packet that is indeed lost and one that is merely late in arriving\\nat the destination.\\n\\nThe third class of failure is at the node and link level; that is, a physical\\nlink is cut, or the computer it is connected to crashes. This can be caused\\nby software that crashes, a power failure, or a reckless backhoe operator.\\nFailures due to misconguration of a network device are also common.\\nWhile any of these failures can eventually be corrected, they can have a\\ndramatic effect on the network for an extended period of time. However,\\nthey need not totally disable the network. In a packet-switched network,\\n\\n\\f\", \"55\": \"PETERSON-AND-DAVIE 07-ch01-000-069-9780123850591 2011/11/1 9:29 Page 23 #24\\n\\n1.2 Requirements\\n\\n23\\n\\nfor example, it is sometimes possible to route around a failed node or link.\\nOne of the difculties in dealing with this third class of failure is distin-\\nguishing between a failed computer and one that is merely slow or, in the\\ncase of a link, between one that has been cut and one that is very aky\\nand therefore introducing a high number of bit errors.\\n\\nThe key idea to take away from this discussion is that defining useful chan-\\nnels involves both understanding the applications requirements and recognizing\\nthe limitations of the underlying technology. The challenge is to fill in the gap\\nbetween what the application expects and what the underlying technology can\\nprovide. This is sometimes called the semantic gap.\\n\\n1.2.5 Manageability\\n\\nA nal requirement, which seems to be neglected or left till last all\\ntoo often,3 is that networks need to be managed. Managing a network\\nincludes making changes as the network grows to carry more trafc or\\nreach more users, and troubleshooting the network when things go wrong\\nor performance isnt as desired.\\n\\nThis requirement is partly related to the issue of scalability discussed\\naboveas the Internet has scaled up to support billions of users and at\\nleast hundreds of millions of hosts, the challenges of keeping the whole\\nthing running correctly and correctly conguring new devices as they are\\nadded have become increasingly problematic. Conguring a single router\\nin a network is often a task for a trained expert; conguring thousands\\nof routers and guring out why a network of such a size is not behaving\\nas expected can become a task beyond any single human. Furthermore,\\nto make the operation of a network scalable and cost-effective, network\\noperators typically require many management tasks to be automated or\\nat least performed by relatively unskilled personnel.\\n\\nAn important development in networking since we wrote the rst edi-\\ntion of this book is that networks in the home are now commonplace. This\\nmeans that network management is no longer the province of experts but\\nneeds to be accomplished by consumers with little to no special training.\\nThis is sometimes stated as a requirement that networking devices should\\nbe plug-and-playa goal that has proven quite elusive. We will discuss\\n\\n3As we have done in this section.\\n\\n\\f\", \"56\": \"PETERSON-AND-DAVIE 07-ch01-000-069-9780123850591 2011/11/1 9:29 Page 24 #25\\n\\n24\\n\\nCHAPTER 1 Foundation\\n\\nsome ways that this requirement has been addressed in part later on, but\\nit is worth noting for now that improving the manageability of networks\\nremains an important area of current research.\\n\\n1.3 NETWORK ARCHITECTURE\\n\\nIn case you hadnt noticed, the previous section established a pretty sub-\\nstantial set of requirements for network designa computer network\\nmust provide general, cost-effective, fair, and robust connectivity among\\na large number of computers. As if this werent enough, networks do not\\nremain xed at any single point in time but must evolve to accommo-\\ndate changes in both the underlying technologies upon which they are\\nbased as well as changes in the demands placed on them by applica-\\ntion programs. Furthermore, networks must be manageable by humans\\nof varying levels of skill. Designing a network to meet these requirements\\nis no small task.\\n\\nTo help deal with this complexity, network designers have developed\\ngeneral blueprintsusually called network architecturesthat guide the\\ndesign and implementation of networks. This section denes more care-\\nfully what we mean by a network architecture by introducing the central\\nideas that are common to all network architectures. It also introduces\\ntwo of the most widely referenced architecturesthe OSI (or 7-layer)\\narchitecture and the Internet architecture.\\n\\n1.3.1 Layering and Protocols\\n\\nAbstractionthe hiding of details behind a well-dened interfaceis\\nthe fundamental tool used by system designers to manage complexity.\\nThe idea of an abstraction is to dene a model that can capture some\\nimportant aspect of the system, encapsulate this model in an object that\\nprovides an interface that can be manipulated by other components of\\nthe system, and hide the details of how the object is implemented from\\nthe users of the object. The challenge is to identify abstractions that\\nsimultaneously provide a service that proves useful in a large number of\\nsituations and that can be efciently implemented in the underlying sys-\\ntem. This is exactly what we were doing when we introduced the idea of\\na channel in the previous section: we were providing an abstraction for\\napplications that hides the complexity of the network from application\\nwriters.\\n\\n\\f\", \"57\": \"PETERSON-AND-DAVIE 07-ch01-000-069-9780123850591 2011/11/1 9:29 Page 25 #26\\n\\n1.3 Network architecture\\n\\n25\\n\\nAbstractions naturally lead to layering, especially in network systems.\\nThe general idea is that you start with the services offered by the underly-\\ning hardware and then add a sequence of layers, each providing a higher\\n(more abstract) level of service. The services provided at the high lay-\\ners are implemented in terms of the services provided by the low layers.\\nDrawing on the discussion of requirements given in the previous section,\\nfor example, we might imagine a simple network as having two lay-\\ners of abstraction sandwiched between the application program and the\\nunderlying hardware, as illustrated in Figure 1.8. The layer immediately\\nabove the hardware in this case might provide host-to-host connectivity,\\nabstracting away the fact that there may be an arbitrarily complex net-\\nwork topology between any two hosts. The next layer up builds on the\\navailable host-to-host communication service and provides support for\\nprocess-to-process channels, abstracting away the fact that the network\\noccasionally loses messages, for example.\\n\\nLayering provides two nice features. First, it decomposes the problem\\nof building a network into more manageable components. Rather than\\nimplementing a monolithic piece of software that does everything you\\nwill ever want, you can implement several layers, each of which solves\\none part of the problem. Second, it provides a more modular design. If\\nyou decide that you want to add some new service, you may only need to\\nmodify the functionality at one layer, reusing the functions provided at all\\nthe other layers.\\n\\nThinking of a system as a linear sequence of layers is an oversimplica-\\ntion, however. Many times there are multiple abstractions provided at any\\ngiven level of the system, each providing a different service to the higher\\nlayers but building on the same low-level abstractions. To see this, con-\\nsider the two types of channels discussed in Section 1.2.4: One provides a\\n\\nApplication programs\\n\\nProcess-to-process channels\\n\\nHost-to-host connectivity\\n\\nHardware\\n\\nI FIGURE 1.8 Example of a layered network system.\\n\\n\\f\", \"58\": \"PETERSON-AND-DAVIE 07-ch01-000-069-9780123850591 2011/11/1 9:29 Page 26 #27\\n\\n26\\n\\nCHAPTER 1 Foundation\\n\\nApplication programs\\n\\nRequest/reply\\n\\nMessage stream\\n\\nchannel\\n\\nchannel\\n\\nHost-to-host connectivity\\n\\nHardware\\n\\nI FIGURE 1.9 Layered system with alternative abstractions available at a given layer.\\n\\nrequest/reply service and one supports a message stream service. These\\ntwo channels might be alternative offerings at some level of a multilevel\\nnetworking system, as illustrated in Figure 1.9.\\n\\nUsing this discussion of layering as a foundation, we are now ready\\nto discuss the architecture of a network more precisely. For starters, the\\nabstract objects that make up the layers of a network system are called\\nprotocols. That is, a protocol provides a communication service that\\nhigher-level objects (such as application processes, or perhaps higher-\\nlevel protocols) use to exchange messages. For example, we could imagine\\na network that supports a request/reply protocol and a message stream\\nprotocol, corresponding to the request/reply and message stream chan-\\nnels discussed above.\\n\\nEach protocol denes two different interfaces. First, it denes a ser-\\nvice interface to the other objects on the same computer that want to use\\nits communication services. This service interface denes the operations\\nthat local objects can perform on the protocol. For example, a request/\\nreply protocol would support operations by which an application can\\nsend and receive messages. An implementation of the HTTP protocol\\ncould support an operation to fetch a page of hypertext from a remote\\nserver. An application such as a web browser would invoke such an oper-\\nation whenever the browser needs to obtain a new page (e.g., when the\\nuser clicks on a link in the currently displayed page).\\n\\nSecond, a protocol denes a peer interface to its counterpart (peer) on\\nanother machine. This second interface denes the form and meaning\\nof messages exchanged between protocol peers to implement the com-\\nmunication service. This would determine the way in which a request/\\nreply protocol on one machine communicates with its peer on another\\nmachine. In the case of HTTP, for example, the protocol specication\\n\\n\\f\", \"59\": \"PETERSON-AND-DAVIE 07-ch01-000-069-9780123850591 2011/11/1 9:29 Page 27 #28\\n\\n1.3 Network architecture\\n\\n27\\n\\nHost 1\\n\\nHost 2\\n\\nHigh-level\\n\\nobject\\n\\nService\\ninterface\\n\\nProtocol\\n\\nHigh-level\\n\\nobject\\n\\nService\\ninterface\\n\\nProtocol\\n\\nPeer-to-peer\\n\\ninterface\\n\\nI FIGURE 1.10 Service interfaces and peer interfaces.\\n\\ndenes in detail how a GET command is formatted, what arguments can\\nbe used with the command, and how a web server should respond when\\nit receives such a command. (We will look more closely at this particular\\nprotocol in\\n\\nTo summarize, a protocol denes a communication service that it\\nexports locally (the service interface), along with a set of rules governing\\nthe messages that the protocol exchanges with its peer(s) to implement\\nthis service (the peer interface). This situation is illustrated in Figure 1.10.\\n\\nExcept at the hardware level, where peers directly communicate with\\neach other over a link, peer-to-peer communication is indirecteach\\nprotocol communicates with its peer by passing messages to some lower-\\nlevel protocol, which in turn delivers the message to its peer. In addition,\\nthere are potentially multiple protocols at any given level, each provid-\\ning a different communication service. We therefore represent the suite\\nof protocols that make up a network system with a protocol graph. The\\nnodes of the graph correspond to protocols, and the edges represent\\na depends on relation. For example, Figure 1.11 illustrates a protocol\\ngraph for the hypothetical layered system we have been discussing\\nprotocols RRP (Request/Reply Protocol) and MSP (Message Stream Pro-\\ntocol) implement two different types of process-to-process channels,\\nand both depend on the Host-to-Host Protocol (HHP) which provides a\\nhost-to-host connectivity service.\\n\\nIn this example, suppose that the le access program on host 1 wants\\nto send a message to its peer on host 2 using the communication service\\n\\n\\f\", \"60\": \"PETERSON-AND-DAVIE 07-ch01-000-069-9780123850591 2011/11/1 9:29 Page 28 #29\\n\\n28\\n\\nCHAPTER 1 Foundation\\n\\nHost 1\\n\\nHost 2\\n\\nFile\\n\\napplication\\n\\nDigital\\nlibrary\\n\\napplication\\n\\nVideo\\n\\napplication\\n\\nFile\\n\\napplication\\n\\nDigital\\nlibrary\\n\\napplication\\n\\nVideo\\n\\napplication\\n\\nRRP\\n\\nMSP\\n\\nRRP\\n\\nMSP\\n\\nHHP\\n\\nHHP\\n\\nI FIGURE 1.11 Example of a protocol graph.\\n\\noffered by RRP. In this case, the le application asks RRP to send the mes-\\nsage on its behalf. To communicate with its peer, RRP invokes the services\\nof HHP, which in turn transmits the message to its peer on the other\\nmachine. Once the message has arrived at the instance of HHP on host 2,\\nHHP passes the message up to RRP, which in turn delivers the message\\nto the le application. In this particular case, the application is said to\\nemploy the services of the protocol stack RRP/HHP.\\n\\nNote that the term protocol is used in two different ways. Sometimes it\\nrefers to the abstract interfacesthat is, the operations dened by the ser-\\nvice interface and the form and meaning of messages exchanged between\\npeers, and sometimes it refers to the module that actually implements\\nthese two interfaces. To distinguish between the interfaces and the mod-\\nule that implements these interfaces, we generally refer to the former\\nas a protocol specication. Specications are generally expressed using a\\ncombination of prose, pseudocode, state transition diagrams, pictures of\\n\\n\\f\", \"61\": \"PETERSON-AND-DAVIE 07-ch01-000-069-9780123850591 2011/11/1 9:29 Page 29 #30\\n\\n1.3 Network architecture\\n\\n29\\n\\npacket formats, and other abstract notations. It should be the case that\\na given protocol can be implemented in different ways by different pro-\\ngrammers, as long as each adheres to the specication. The challenge\\nis ensuring that two different implementations of the same specication\\ncan successfully exchange messages. Two or more protocol modules that\\ndo accurately implement a protocol specication are said to interoperate\\nwith each other.\\n\\nWe can imagine many different protocols and protocol graphs that\\nsatisfy the communication requirements of a collection of applications.\\nFortunately, there exist standardization bodies, such as the Internet Engi-\\nneering Task Force (IETF) and the International Standards Organization\\n(ISO), that establish policies for a particular protocol graph. We call the\\nset of rules governing the form and content of a protocol graph a network\\narchitecture. Although beyond the scope of this book, standardization\\nbodies have established well-dened procedures for introducing, validat-\\ning, and nally approving protocols in their respective architectures. We\\nbriey describe the architectures dened by the IETF and ISO shortly,\\nbut rst there are two additional things we need to explain about the\\nmechanics of protocol layering.\\n\\nEncapsulation\\nConsider what happens in Figure 1.11 when one of the application pro-\\ngrams sends a message to its peer by passing the message to RRP. From\\nRRPs perspective, the message it is given by the application is an unin-\\nterpreted string of bytes. RRP does not care that these bytes represent\\nan array of integers, an email message, a digital image, or whatever; it is\\nsimply charged with sending them to its peer. However, RRP must com-\\nmunicate control information to its peer, instructing it how to handle the\\nmessage when it is received. RRP does this by attaching a header to the\\nmessage. Generally speaking, a header is a small data structurefrom a\\nfew bytes to a few dozen bytesthat is used among peers to communi-\\ncate with each other. As the name suggests, headers are usually attached\\nto the front of a message. In some cases, however, this peer-to-peer con-\\ntrol information is sent at the end of the message, in which case it is called\\na trailer. The exact format for the header attached by RRP is dened by its\\nprotocol specication. The rest of the messagethat is, the data being\\ntransmitted on behalf of the applicationis called the messages body\\nor payload. We say that the applications data is encapsulated in the new\\nmessage created by RRP.\\n\\n\\f\", \"62\": \"PETERSON-AND-DAVIE 07-ch01-000-069-9780123850591 2011/11/1 9:29 Page 30 #31\\n\\n30\\n\\nCHAPTER 1 Foundation\\n\\nThis process of encapsulation is then repeated at each level of the pro-\\ntocol graph; for example, HHP encapsulates RRPs message by attaching\\na header of its own. If we now assume that HHP sends the message to\\nits peer over some network, then when the message arrives at the des-\\ntination host, it is processed in the opposite order: HHP rst interprets\\nthe HHP header at the front of the message (i.e., takes whatever action is\\nappropriate given the contents of the header) and passes the body of the\\nmessage (but not the HHP header) up to RRP, which takes whatever action\\nis indicated by the RRP header that its peer attached and passes the body\\nof the message (but not the RRP header) up to the application program.\\nThe message passed up from RRP to the application on host 2 is exactly\\nthe same message as the application passed down to RRP on host 1; the\\napplication does not see any of the headers that have been attached to\\nit to implement the lower-level communication services. This whole pro-\\ncess is illustrated in Figure 1.12. Note that in this example, nodes in the\\n\\nHost 1\\n\\nHost 2\\n\\nApplication\\n\\nprogram\\n\\nData\\n\\nRRP\\n\\nRRP Data\\n\\nHHP\\n\\nApplication\\n\\nprogram\\n\\nData\\n\\nRRP\\n\\nHHP\\n\\nRRP Data\\n\\nHHP RRP Data\\n\\nI FIGURE 1.12 High-level messages are encapsulated inside of low-level messages.\\n\\n\\f\", \"63\": \"PETERSON-AND-DAVIE 07-ch01-000-069-9780123850591 2011/11/1 9:29 Page 31 #32\\n\\n1.3 Network architecture\\n\\n31\\n\\nnetwork (e.g., switches and routers) may inspect the HHP header at the\\nfront of the message.\\n\\nNote that when we say a low-level protocol does not interpret the mes-\\nsage it is given by some high-level protocol, we mean that it does not\\nknow how to extract any meaning from the data contained in the mes-\\nsage. It is sometimes the case, however, that the low-level protocol applies\\nsome simple transformation to the data it is given, such as to compress\\nor encrypt it. In this case, the protocol is transforming the entire body\\nof the message, including both the original applications data and all the\\nheaders attached to that data by higher-level protocols.\\n\\nMultiplexing and Demultiplexing\\nRecall from Section 1.2.3 that a fundamental idea of packet switching is\\nto multiplex multiple ows of data over a single physical link. This same\\nidea applies up and down the protocol graph, not just to switching nodes.\\nIn Figure 1.11, for example, we can think of RRP as implementing a logical\\ncommunication channel, with messages from two different applications\\nmultiplexed over this channel at the source host and then demultiplexed\\nback to the appropriate application at the destination host.\\n\\nPractically speaking, this simply means that the header that RRP\\nattaches to its messages contains an identier that records the application\\nto which the message belongs. We call this identier RRPs demultiplexing\\nkey, or demux key for short. At the source host, RRP includes the appro-\\npriate demux key in its header. When the message is delivered to RRP on\\nthe destination host, it strips its header, examines the demux key, and\\ndemultiplexes the message to the correct application.\\n\\nRRP is not unique in its support for multiplexing; nearly every protocol\\nimplements this mechanism. For example, HHP has its own demux key\\nto determine which messages to pass up to RRP and which to pass up\\nto MSP. However, there is no uniform agreement among protocolseven\\nthose within a single network architectureon exactly what constitutes a\\ndemux key. Some protocols use an 8-bit eld (meaning they can support\\nonly 256 high-level protocols), and others use 16- or 32-bit elds. Also,\\nsome protocols have a single demultiplexing eld in their header, while\\nothers have a pair of demultiplexing elds. In the former case, the same\\ndemux key is used on both sides of the communication, while in the latter\\ncase each side uses a different key to identify the high-level protocol (or\\napplication program) to which the message is to be delivered.\\n\\n\\f\", \"64\": \"PETERSON-AND-DAVIE 07-ch01-000-069-9780123850591 2011/11/1 9:29 Page 32 #33\\n\\n32\\n\\nCHAPTER 1 Foundation\\n\\nThe 7-Layer Model\\nThe ISO was one of the rst organizations to formally dene a common\\nway to connect computers. Their architecture, called the Open Systems\\nInterconnection (OSI) architecture and illustrated in Figure 1.13, denes a\\npartitioning of network functionality into seven layers, where one or more\\nprotocols implement the functionality assigned to a given layer. In this\\nsense, the schematic given in Figure 1.13 is not a protocol graph, per se,\\nbut rather a reference model for a protocol graph. It is often referred to as\\nthe 7-layer model.\\n\\nStarting at the bottom and working up, the physical layer handles the\\ntransmission of raw bits over a communications link. The data link layer\\nthen collects a stream of bits into a larger aggregate called a frame. Net-\\nwork adaptors, along with device drivers running in the nodes operating\\n\\nEnd host\\n\\nApplication\\n\\nPresentation\\n\\nSession\\n\\nTransport\\n\\nNetwork\\n\\nData link\\n\\nPhysical\\n\\nNetwork\\n\\nNetwork\\n\\nData link\\n\\nData link\\n\\nPhysical\\n\\nPhysical\\n\\nOne or more nodes\\nwithin the network\\n\\nI FIGURE 1.13 The OSI 7-layer model.\\n\\nEnd host\\n\\nApplication\\n\\nPresentation\\n\\nSession\\n\\nTransport\\n\\nNetwork\\n\\nData link\\n\\nPhysical\\n\\n\\f\", \"65\": \"PETERSON-AND-DAVIE 07-ch01-000-069-9780123850591 2011/11/1 9:29 Page 33 #34\\n\\n1.3 Network architecture\\n\\n33\\n\\nsystem, typically implement the data link level. This means that frames,\\nnot raw bits, are actually delivered to hosts. The network layer handles\\nrouting among nodes within a packet-switched network. At this layer, the\\nunit of data exchanged among nodes is typically called a packet rather\\nthan a frame, although they are fundamentally the same thing. The lower\\nthree layers are implemented on all network nodes, including switches\\nwithin the network and hosts connected to the exterior of the network.\\nThe transport layer then implements what we have up to this point been\\ncalling a process-to-process channel. Here, the unit of data exchanged is\\ncommonly called a message rather than a packet or a frame. The trans-\\nport layer and higher layers typically run only on the end hosts and not\\non the intermediate switches or routers.\\n\\nThere is less agreement about the denition of the top three layers,\\nin part because they are not always all present, as we will see below.\\nSkipping ahead to the top (seventh) layer, we nd the application layer.\\nApplication layer protocols include things like the Hypertext Transfer Pro-\\ntocol (HTTP), which is the basis of the World Wide Web and is what\\nenables web browsers to request pages from web servers. Below that,\\nthe presentation layer is concerned with the format of data exchanged\\nbetween peersfor example, whether an integer is 16, 32, or 64 bits long,\\nwhether the most signicant byte is transmitted rst or last, or how a\\nvideo stream is formatted. Finally, the session layer provides a name space\\nthat is used to tie together the potentially different transport streams that\\nare part of a single application. For example, it might manage an audio\\nstream and a video stream that are being combined in a teleconferencing\\napplication.\\n\\n1.3.2 Internet Architecture\\n\\nThe Internet architecture, which is also sometimes called the TCP/IP\\narchitecture after its two main protocols, is depicted in Figure 1.14. An\\nalternative representation is given in Figure 1.15. The Internet architec-\\nture evolved out of experiences with an earlier packet-switched network\\ncalled the ARPANET. Both the Internet and the ARPANET were funded by\\nthe Advanced Research Projects Agency (ARPA), one of the research and\\ndevelopment funding agencies of the U.S. Department of Defense. The\\nInternet and ARPANET were around before the OSI architecture, and the\\nexperience gained from building them was a major inuence on the OSI\\nreference model.\\n\\n\\f\", \"66\": \"PETERSON-AND-DAVIE 07-ch01-000-069-9780123850591 2011/11/1 9:29 Page 34 #35\\n\\n34\\n\\nCHAPTER 1 Foundation\\n\\nFTP\\n\\nHTTP\\n\\nNV\\n\\nTFTP\\n\\nTCP\\n\\nUDP\\n\\nIP\\n\\nNET1\\n\\nNET2\\n\\nNETn\\n\\nI FIGURE 1.14 Internet protocol graph.\\n\\nApplication\\n\\nTCP UDP\\n\\nIP\\n\\nSubnetwork\\n\\nI FIGURE 1.15 Alternative view of the Internet architecture. The subnetwork layer was historically referred to as the\\nnetwork layer and is now often referred to as the layer or simply layer 2.\\n\\nWhile the 7-layer OSI model can, with some imagination, be applied\\nto the Internet, a 4-layer model is often used instead. At the lowest level\\nis a wide variety of network protocols, denoted NET1, NET2, and so\\non. In practice, these protocols are implemented by a combination of\\nhardware (e.g., a network adaptor) and software (e.g., a network device\\ndriver). For example, you might nd Ethernet or wireless protocols (such\\nas the 802.11 Wi-Fi standards) at this layer. (These protocols in turn may\\nactually involve several sublayers, but the Internet architecture does not\\npresume anything about them.) The second layer consists of a single\\nprotocolthe Internet Protocol (IP). This is the protocol that supports the\\ninterconnection of multiple networking technologies into a single, logical\\ninternetwork. The third layer contains two main protocolsthe Trans-\\nmission Control Protocol (TCP) and the User Datagram Protocol (UDP).\\nTCP and UDP provide alternative logical channels to application pro-\\ngrams: TCP provides a reliable byte-stream channel, and UDP provides\\nan unreliable datagram delivery channel (datagram may be thought of as\\na synonym for message). In the language of the Internet, TCP and UDP\\n\\n\\f\"}";

        //        try {
//            text = new Scanner(new File(Uri.parse("file:///android_assets/computernetworks.json"))).useDelimiter("\\A").next();
//        } catch (FileNotFoundException e) {
//            e.printStackTrace();
//        }
//        new Scanner(textDatabase)
//        JsonReader reader = new JsonReader(new FileReader(textDatabase));
        Type type = new TypeToken<LinkedHashMap<Integer, String>>() {}.getType() ; // wtf

        this.textDatabase = new Gson().fromJson(text, type);
        if (this.textDatabase.isEmpty()) {
            Log.e("[OCRAnalyzer]", "Text database empty!" + textDatabase.toString());
        }

        this.context = context;

    }

    public void matchText(Text text) {
        String t = text.getText();
        if (t.length() > 100 && MATCHING_MODE.equals("partial")) {
            t = t.substring(t.length() / 2 - 50, t.length() / 2 + 50);
        }

        HashMap<Integer, Integer> scores = new HashMap<>();
        for (Entry<Integer, String> entry : textDatabase.entrySet()) {
            Integer score = MATCHING_MODE.equals("partial") ? FuzzySearch.partialRatio(t, entry.getValue()) : FuzzySearch.ratio(t, entry.getValue());
            scores.put(entry.getKey(), score);
        }

        Integer bestMatch = Collections.max(scores.entrySet(), Map.Entry.comparingByValue()).getKey();
        Integer bestScore = scores.get(bestMatch);

        Log.i("[OCRAnalyzer]", "Best match: page " + bestMatch.toString() + " score " + bestScore.toString());
        Log.d("[OCRAnalyzer]", scores.toString());
        if (bestScore > 75) {
            if (lastToast != null) {
                lastToast.cancel();
            }
            lastToast = Toast.makeText(
                    context.getApplicationContext(), "MATCHED page " + bestMatch.toString() + " score " + bestScore.toString(), Toast.LENGTH_SHORT);
            lastToast.show();
        }
    }

    public void analyze(Frame frame) {
        Image image;

        // We only process one image at a time, even if ARCore takes many more
        // If we are mid-processing, we drop future requests
        if (blocked) {
            //            image.close();
            return;
        } else {
            try {
                image = frame.acquireCameraImage();
            } catch (NotYetAvailableException e) {
                Log.w("[OCRAnalyzer]", "NotYetAvailableException");
                return;
            }
            blocked = true;
        }

        // Note: hard-coded vertical orientation. Might not work on other devices??
        InputImage inputImage = InputImage.fromMediaImage(image, 90);
        image.close();

        analyze(inputImage);
    }

    public void analyze(InputImage inputImage) {
        blocked = true;

        Task<Text> result = recognizer.process(inputImage)
                .addOnSuccessListener(new OnSuccessListener<Text>() {
                    @Override
                    public void onSuccess(Text text) {
                        Log.i("[OCRAnalyzer]", "Detected Text " + text.getText().length());

                        if (text.getText().length() > 100) {
                            long t = System.currentTimeMillis();
                            matchText(text);
                            Log.v("[OCRAnalyzer]", "Search took " + Long.toString(System.currentTimeMillis() - t));
                        }

                        blocked = false;
                    }
                })
                .addOnFailureListener(new OnFailureListener() {
                    @Override
                    public void onFailure(@NonNull Exception e) {
                        Log.e("[OCRAnalyzer]", "Failed: " + e.toString());
//                        image.close();
                        blocked = false;
                    }
                });
    }
}